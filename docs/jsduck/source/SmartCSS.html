<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var _          = require('lodash');
var tinycolor  = require('tinycolor2');
var StyleClass = require('./StyleClass');
var Slick      = require('slick');
var utils      = require('../utils');





<span id='core-SmartCSS'>/**
</span> * @class core.SmartCSS
 * This is the main class you will be using in smart-css.
 * When you do `require('smart-css')` you will get this class. (Remember you need to instance it.)
 *
 *
 * Definitions:
 *
 *  - **Class id:** is the name in smart-css, normally is semantic and needs context; A class
 *                  id only matters if has a SmartCSS instance associated. Alone means nothing.
 *  - **Class name:** is the real css class, normally is ugly and short; Doesn't include the pseudo
 *                    part or the dot prefix.
 *
 * @param {Object} options
 * @param {String|undefined} [options.name=undefined]
 *        Provides a name for this context. If you enable debug you will see this
 *        `options.name` in your generated class names.
 * @param {Boolean} [options.debug=true]
 *        Prefixes all style ids with the style name.
 *        For example if you you set this to true the class names
 *        generated will have the prefix the style name and then
 *        the id.
 */
var SmartCSS = function(options){
    options = _.extend({
        name  : undefined,
        debug : true,
    }, options);

<span id='core-SmartCSS-property-__name'>    /**
</span>     * The name of this SmartCSS instance. If #__debug is set to true then it will render this name
     * in the class names.
     * @private
     * @type {String|undefined}
     */
    this.__name = options.name;

<span id='core-SmartCSS-property-__debug'>    /**
</span>     * If the parameter is set to debug then you will get longer and more descriptive class names.
     * @private
     * @type {Boolean}
     */
    this.__debug = options.debug;

<span id='core-SmartCSS-property-__childContexts'>    /**
</span>     * Contains all the SmartCSS instances that are a child to this SmartCSS instance.
     * @private
     * @type {Array}
     */
    this.__childContexts = [];

<span id='core-SmartCSS-property-__styleClasses'>    /**
</span>     * The key is the styleName and the value is an object like this:
     * `{className: 'String', style: {color: 'red'}}`
     * @type {Object}
     * @private
     */
    this.__styleClasses = {};

<span id='core-SmartCSS-property-__classNameMap'>    /**
</span>     * The key is classId and maps to a className.
     * @type {Object}
     * @private
     */
    this.__classNameMap = {};

    SmartCSS.__registerContext(this);
}



<span id='core-SmartCSS-property-__data'>/**
</span> * @property {Object} __data Contains static information about SmartCSS classes.
 * @private
 * @type {Object}
 */
SmartCSS.__data = {
    styles   : {},
    contexts : [],
    index    : 0,
};



<span id='core-SmartCSS-static-method-__registerContext'>/**
</span> * @method __registerContext
 * Register a context.
 * @static
 * @private
 * @param  {core.SmartCSS} context
 */
SmartCSS.__registerContext = function(context){
    SmartCSS.__data.contexts.push(context);
}



// Not yet used. In the future we can use this to make shorter ids.
// var alphabet = &quot;abcdefghijklmnopqrstuvwxyz&quot;;
// alphabet = (alphabet + alphabet.toUpperCase()).split('');
<span id='core-SmartCSS-static-method-__getNextId'>/**
</span> * @method __getNextId
 * Gets a new id. Is a singleton therefore it will always be different.
 * @private
 * @static
 * @return {String}
 */
SmartCSS.__getNextId = function(){
    return SmartCSS.__data.index++;
}



<span id='core-SmartCSS-static-method-injectStyles'>/**
</span> * @method injectStyles
 * After you add the styles call this function to inject the styles into your DOM.
 * @static
 */
SmartCSS.injectStyles = function(){
    var tag = document.createElement('style');
    tag.innerHTML = SmartCSS.getStylesAsString();
    document.getElementsByTagName('head')[0].appendChild(tag);
}



<span id='core-SmartCSS-static-method-deleteStyles'>/**
</span> * @method deleteStyles
 * Deletes all the cached styles. This will not affect the current applied styles.
 * Only affects future calls to #injectStyles or #getStylesAsString.
 * @static
 */
SmartCSS.deleteStyles = function(){
    SmartCSS.__data.styles = {};
    SmartCSS.__data.contexts = [];
}



<span id='core-SmartCSS-static-method-getStylesAsString'>/**
</span> * @method getStylesAsString
 * After you add the styles call this function to get the styles as string.
 * @static
 */
SmartCSS.getStylesAsString = function(){
    var contexts = SmartCSS.__data.contexts;
    var str = [];
    contexts.forEach(function(context){
        str.push(context.getStylesAsString());
    })
    return str.join('');
}





_.extend(SmartCSS.prototype, {



<span id='core-SmartCSS-method-getClass'>    /**
</span>     * Returns the class name (the one that will be really added to the css).
     * Don't add any pseudo things. For example if you set a class like this:
     *
     *     setClass('myClass:hover', ...);
     *
     * In order to get the className you do:
     *
     *     getClass('myClass');
     *
     * And not
     *
     *     getClass('myClass:hover');
     *
     * @param  {String} styleName
     * @return {String} The class id. This is the real class that is attached to the DOM.
     */
    getClass: function(classId){
        // Warn if class is missing and return '' by default.
        if(this.__classNameMap[classId] === undefined){
            console.warn('Class &quot;' + classId + '&quot; not set.');
            return '';
        }
        return this.__classNameMap[classId];
    },



<span id='core-SmartCSS-method-getClassNameMap'>    /**
</span>     * Returns a copy of #__classNameMap, look at it for more info.
     * The key is the class id and the value is the class name.
     * @return {Object}
     */
    getClassNameMap: function(){
        return _.clone(this.__classNameMap);
    },



<span id='core-SmartCSS-method-getStyleClasses'>    /**
</span>     * @return {Array} An array with all the style classes added.
     */
    getStyleClasses: function(){
        return _.values(this.__styleClasses);
    },



<span id='core-SmartCSS-method-getClasses'>    /**
</span>     * Returns multiple classes.
     * Example:
     *
     *     css.getClasses({
     *         a: true,
     *         b: false,
     *         c: true,
     *     });
     *     // Will return a string with the class for `a` and `b` only.
     * @param {Object} styleNames Example {returnThisClass: true, dontReturnThisClass: false}
     * @param {Boolean} [asArray=true] If true returns an array, if not returns a string.
     * @return {String} The classes' ids. These are the real classes that are attached to the DOM.
     */
    getClasses: function(styleNames, asArray){
        var classesAsArray = [];
        _.forEach(styleNames, function(include, styleName){
            if(include){
                classesAsArray.push(this.getClass(styleName));
            }
        }.bind(this))
        if(asArray){
            return classesAsArray;
        }else{
            return classesAsArray.join(' ');
        }
    },




<span id='core-SmartCSS-method-__validateSelectorObject'>    /**
</span>     * Checks whenever the selector object is a valid one
     * for this library.
     * @private
     * @param  {Object} selectorObject
     */
    __validateSelectorObject: function(selectorObject){
        // Should only have one selector. Filters out: &quot;.a, .b&quot;;
        if(selectorObject.length &gt; 1){
            throw new Error('Doesn\'t accept multiple definitions at once.');
        }
        // Should only have only 1 class per segment. Filters out: &quot;.a.b&quot;;
        _.forEach(selectorObject[0], function(segment){
            if(segment.classList.length &gt; 1) throw new Error('Doesn\'t accept multiple classes at once.')
        })

        // We only care about the first one.
        selectorObject = selectorObject[0];

        // Checks whenever ancestors are defined.
        _.forEach(selectorObject, function(segment, i){
            // The last one obviously is not yet added to the set, therefore
            // no need to test it.
            var last = selectorObject.length - 1 === i;
            if(last) return;
            if(this.getClass(segment.classList[0]) === ''){
                throw new Error('Ancestor not defined.')
            }
        }.bind(this))
    },



<span id='core-SmartCSS-method-setClass'>    /**
</span>     * Defines a style.
     * @param {String} name The style name, then you can get the style id with `getClass` or `getClasses`.
     * @param {Object} def The style definition `{color: 'red'}` as javascript object.
     * @param {Object} options
     * @param {String} options.className
     * @param {String} options.hover
     * @param {String} options.media
     */
    setClass: function(selector, styleDef, options){
        if(this.__styleClasses[selector]){
            throw new Error('Class id already exists for this selector')
        }
        // Converts the selector string to a JavaScript object so its easier to
        // understand what the user defines.
        var selectorObject = Slick.parse(selector);
        this.__validateSelectorObject(selectorObject);
        selectorObject = selectorObject[0];
        var classId = _.last(selectorObject).classList[0];

        options = _.extend({
            className : undefined,
            classId   : classId,
        }, options)

        if(options.className !== undefined &amp;&amp; this.getClass(classId) !== ''){
            throw new Error('Can\'t use hardcoded class name because already exists one for the same class id');
        }

        var className = options.className;
        if(options.className === undefined){
            className = '';
            // If a class with the same classId has been defined then reuse
            // its className so :hover and other pseudo things works correctly.
            if(this.__styleClasses[classId]){
                className = this.__styleClasses[classId].getClassName();
            }else{
                if(this.__debug){
                    className += classId;
                    if(this.__name){
                        className = this.__name + '-' + className
                    }
                }else{
                    className = '_' + className;
                }
            }
            className += SmartCSS.__getNextId();
        }
        if(!utils.isValidClassName(className)){
            throw new Error('Invalid class name');
        }
        options.className = className;

        var styleClass = new StyleClass({
            className      : options.className,
            selectorString : selector,
            selectorObject : selectorObject,
            styleDef       : styleDef,
            media          : options.media,
        })
        this.__classNameMap[classId] = className;
        this.__styleClasses[selector] = styleClass;
        return this.__styleClasses[selector];
    },



<span id='core-SmartCSS-method-getStylesAsString'>    /**
</span>     * @return {String} All styles added as string.
     */
    getStylesAsString: function(){
        var str = [];
        var classNamesAsMap = this.getClassNameMap();
        this.getStyleClasses().forEach(function(styleClass){
            str.push(utils.renderStyleClass(styleClass, classNamesAsMap));
        });
        this.__childContexts.forEach(function(context){
            str.push(context.getStylesAsString());
        })
        return str.join('');
    },



<span id='core-SmartCSS-method-addChildContext'>    /**
</span>     * Adds a new context. This is useful if you don't want to use the
     * singleton.
     * @param {core.SmartCSS} smartCSS
     */
    addChildContext: function(smartCSS){
        if(_.includes(this.__childContexts, smartCSS)) throw new Error('The same child context already exists')
        this.__childContexts.push(smartCSS);
    }



})





module.exports = SmartCSS;
</pre>
</body>
</html>
